# 리스트
# colors = ['red', 'blue', 'green']  # 리스트 선언
"""
한 개의 변수에 여러 개의 값을 할당하는 방식인 배열, 파이썬에선 리스트라고 불리는 개념이 있다.
위의 예시에서 보는 것과 같이 colors 라는 변수에 red, blue, green 이라는 세 개의 문자열 값이 저장이 되는 것이다.
리스트는 선언을 함과 동시에 그 배열의 크기가 유동적으로 정해진다.
"""

# 인덱싱(indexing)
# print(colors[0])  # red : 리스트의 0번째에 해당하는 값을 출력
# print(colors[2])  # green : 리스트의 2번째에 해당하는 값을 출력
"""
위와 같이 리스트의 값들 중 일부 값만 이용하고 싶을 경우 해당하는 값만 접근할 수 있도록 상대적 주소를 이용하는 것을 인덱싱이라 한다.
주소는 맨 왼쪽의 첫 번째 값을 0이라고 기준을 두고 그 값과 얼마나 떨어져있는지 표현한 값이다. 그 주소를 인덱스 주소, 인덱스값이라 한다.
***TMI***
Q. 배열의 주소값은 왜 1부터가 아니라 0부터 시작하나요?
A. 0부터 시작하면 이진수 관점에서 메모리를 절약할 수 있다는 장점이 있기 때문!
초기 컴퓨터들은 메모리 절약이 매우 큰 이슈였기 때문에 이 점이 중요했지만 지금은 큰 문제가 되지 않아 매트랩 같은 언어는 1부터 인덱싱한다.
"""
# print(len(colors))  # 3 : colors의 길이는 red, blue, green으로 세 개의 값이 할당돼있어서 3이다.
"""
len() 함수의 len은 length의 준말로, 리스트의 길이를 반환하는 함수이다.
"""

# 슬라이싱(slicing)
# cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']  # 리스트 선언
# print(cities[0:6])  # ['서울', '부산', '인천', '대구', '대전', '광주'] : 0번째부터 5(6-1)번째까지 출력
# print(cities[5:])  # ['광주', '울산', '수원'] : 5번째부터 마지막까지 출력
# print(cities[:4])  # ['서울', '부산', '인천', '대구'] : 첫번째부터 3(4-1)번째 까지 출력
# print(cities[:])  # ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원'] : 첫번째부터 마지막까지 출력
# print(cities[-50:50])  # ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원'] : 범위를 넘어가 시작부터 끝까지 출력
"""
리스트의 인덱싱이 하나의 값만 가져오는 것이라면 슬라이싱은 전체에서 원하는 일부분을 잘라 가져오는 것이라 할 수 있다.
변수명[시작 인덱스:마지막 인덱스] 로 기본 문법을 작성한다.
이는 보통 마지막 인덱스까지 포함해서 슬라이싱된다고 생각하지만 실제로는 '마지막 인덱스 - 1'까지만 포함한다.
헷갈리기 쉬운 문법이지만 이어서 작성할 시에 앞서 작성한 마지막 인덱스를 시작 인덱스로 그대로 작성할 수 있다는 점은 편리하다.
(ex. cities[0:5] -> ['서울', '부산', '인천', '대구', '대전'] cities[5:] -> ['광주', '울산', '수원'])
시작 인덱스를 비워두면 첫 번째 값부터 '마지막 인덱스 - 1'까지 슬라이싱한다.
마찬가지로 마지막 인덱스를 비워두면 시작 인덱스부터 마지막 값까지 슬라이싱한다.
그리고 범위를 넘어가는 경우는 두 가지가 있는데 시작 인덱스의 경우 첫 번째 값을, 마지막 인덱스의 경우는 마지막 값이 자동으로 저장된다.
"""

# 리버스 인덱스(reverse index)
# cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']  # 리스트 선언
# print(cities[-8:])  # ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
"""
리버스 인덱스는 주소값이 마지막 값을 -1로 할당하고 첫번째 값까지 역순으로 값을 할당하는 방식이다.
위의 예시를 살펴보면 마지막 값 '수원'이 주소로 -1이 할당되고, 길이가 8이니 첫번째 값인 '서울'은 인덱스 주소가 -8인 셈이다.
"""

# 증가값(step)
# cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']  # 리스트 선언
# print(cities[::2])  # ['서울', '인천', '대전', '울산'] : 2칸 단위로 출력
# print(cities[::-1])  # ['수원', '울산', '광주', '대전', '대구', '인천', '부산', '서울'] : 역방향으로 1칸 단위로 출력
"""
슬라이싱을 할 경우 시작 인덱스와 마지막 인덱스 외에 증가값을 넣을 수도 있다.
변수명[시작 인덱스:마지막 인덱스:증가값]을 문법으로 마지막 자리에 증가값을 추가로 작성하면 된다.
증가값이 음수일 경우 절대값의 값만큼의 단위로 역방향으로 슬라이싱한다.
"""

# 리스트 연산
# 덧셈 연산
color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
print(color1 + color2)  # ['red', 'blue', 'green', 'orange', 'black', 'white'] : color1 리스트와 color2리스트의 합
print(len(color1))  # 3 : color1의 길이 (여전히 길이가 3이라는 점에서 변수 자체엔 영향을 주지 않았다는 것을 확인)
total_color = color1 + color2  # 두 리스트의 합을 total_color 변수에 할당
print(total_color)  # ['red', 'blue', 'green', 'orange', 'black', 'white'] : 두 리스트의 합 출력
# 곱셈 연산
print(color1 * 2)  # ['red', 'blue', 'green', 'red', 'blue', 'green'] : color1 리스트 2회 반복 (곱셈은 수 만큼 반복)
# in 연산
print('blue' in color2)  # False : color2 리스트엔 'blue'가 존재하지 않음 (color2 변수에서 문자열 'blue'의 존재 여부 반환)