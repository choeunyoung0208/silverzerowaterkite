"""인덱스 재할당과 삭제"""
color = ['red', 'blue', 'green']  # 리스트 선언
color[0] = 'orange'  # 인덱스의 재할당
print(color)  # ['orange', 'blue', 'green'] : 재할당 후 출력한 리스트
del color[0]  # 인덱스의 삭제
print(color)  # ['blue', 'green'] : 삭제 후 출력한 리스트

"""패킹과 언패킹"""
t = [1, 2, 3]  # 1, 2, 3을 변수 t에 패킹 (변수 t에 리스트 할당)
a, b, c = t  # t에 있는 값 1, 2, 3을 변수 a, b, c에 언패킹 (t에 있는 값을 각각의 변수에 순서대로 할당)
print(t, a, b, c)  # [1, 2, 3] 1 2 3 : 리스트와 값이 새로 할당된 변수들의 출력
# a, b, c, d, e = t  # 에러 발생 : 언패킹 시 할당받는 변수의 개수가 많음
# a, b = t  # 에러 발생 : 언패킹 시 할당받는 변수의 개수가 적음
'''
패킹이란 한 변수에 여러 개의 데이터를 할당하는 것이며 이는 리스트 자체를 뜻하기도 한다.
언패킹은 한 변수에 여러 개의 데이터가 들어 있을 때 그것을 각각의 변수로 반환하는 방법이다.
언패킹 할 경우 할당받는 변수의 개수가 많거나 적으면 에러가 발생한다.
언패킹은 여러 예제 코드나 오픈소스 코드에서 빈번히 나오니 기억해두자!
'''

"""이차원 리스트"""
kor_score = [49, 79, 20, 100, 80]  # 국어 점수 리스트 선언
math_score = [43, 59, 85, 30, 90]  # 수학 점수 리스트 선언
eng_score = [49, 79, 48, 60, 100]  # 영어 점수 리스트 선언
midterm_score = [kor_score, math_score, eng_score]  # 이차원 리스트인 중간고사 점수 리스트 선언
print(midterm_score)  # [[49, 79, 20, 100, 80], [43, 59, 85, 30, 90], [49, 79, 48, 60, 100]] : 이차원 리스트 출력
print(midterm_score[0][2]) # 20 : 0번째 행과 2번째 열에 해당하는 값 출력 (kor_score의 2번째 값)
'''
여러 리스트들을 하나의 값으로 보고, 그 리스트에 있는 값들이 모두 하나의 리스트 변수에 할당되면, 그것을 이차원 리스트라고 할 수 있다.
이차원 리스트에 인덱싱하여 값에 접근하려면 대괄호를 2개 사용하는데, 이를 행렬로 본다면 앞의 대괄호가 행, 뒤의 대괄호가 열이다.
데이터 관리할 시에 이차원 리스트가 자주 사용되니 반드시 이해하고 넘어가야하는 부분이다.
'''

"""리스트의 메모리 저장"""
math_score[0] = 1000  # math_score 리스트 0번째에 1000할당
print(midterm_score)  # [[49, 79, 20, 100, 80], [1000, 59, 85, 30, 90], [49, 79, 48, 60, 100]] : 바뀐 값과 함께 출력

a = 300  # a에 300 할당
b = 300  # b에 300 할당
print(a is b)  # True (phthon IDLE로 실행할 시에 False로 출력)
print(a == b)  # True

a = 1  # a에 1 할당
b = 1  # b에 1 할당
print(a is b)  # True
print(a == b)  # True
'''
math_score에 값을 저장했음에도 불구하고 midterm_score의 값 또한 바뀌는 이유는 파이썬 리스트가 값을 저장하는 방식때문이다.
파이썬은 리스트를 저장할 때 값 자체가 아니라, 값이 위치한 메모리 주소를 저장한다.
또한 a와 b의 값이 동일한 값인 300을 할당받고 있는데 is 와 == 의 연산값이 다르게 도출된다. (IDLE 기준, 사진파일 첨부)
이는 == 연산은 변수에 할당된 값을 비교하는 것이고 is 연산은 메모리의 주소를 비교하는 연산이기 때문이다.
반면 아까 300을 할당하는 것과 달리 1을 할당할 경우엔 is 연산도 True를 출력이 된다.
이는 파이썬의 정수형 저장 방식의 특성 때문이다.
파이썬은 인터프리터가 구동될 때 -5부터 256까지는 정수값을 특정 메모리 주소에 저장한다.
따라서 해당 숫자를 할당하려고 하면 해당 변수는 그 숫자가 가진 메모리 주소로 연결하여 주소와 값이 모두 같은 것으로 나오는 것이다.
'''

"""하나의 리스트에 다양한 자료형 포함 가능"""
a = ["color", 1, 0.2]  # a 변수에 문자형, 정수형, 실수형 할당 (다양한 형태의 변수가 하나의 리스트에 할당 가능)

color = ['yellow', 'blue', 'green', 'black', 'purple']  # color 리스트 선언
a[0] = color  # a 리스트에 0번째에 color 리스트 재할당
print(a)  # [['yellow', 'blue', 'green', 'black', 'purple'], 1, 0.2] : 재할당 후 a 출력
'''
리스트는 다양한 형태의 변수가 하나의 리스트에 할당이 가능하다는 특징을 가지고 있다.
심지어 한 리스트에 또 다른 리스트를 재할당할 수 있다는 기능을 가지고 있는데 이를 중첩 리스트라 한다.
리스트가 값을 저장하는 것이 아닌 메모리 주소를 저장하기 때문에 새로운 값을 할당하는 데 있어서 높은 자유도를 보장해 가능한 일이다.
'''

"""리스트의 저장방식"""
a = [5, 4, 3, 2, 1]  # 리스트 선언
b = [1, 2, 3, 4, 5]  # 리스트 선언
b = a  # 변수 b에 변수 a 값 할당
print(b)  # [5, 4, 3, 2, 1] : 리스트 b에 리스트 a 값을 할당

a.sort()  # a 리스트를 정렬 (sort() 함수는 리스트에 있는 값들의 순서를 오름차순으로 변환하는 함수이다.)
print(b)  # [1, 2, 3, 4, 5] : 정렬된 값이 출력

b = [6, 7, 8, 9, 10]  # b에 새로운 값 할당
print(a, b)  # [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]

'''
a를 정렬을 했는데 b에 할당된 값도 정렬이 되는 이유는 b 리스트도 a 리스트의 메모리 주소와 같이 연결되기 때문이다.
두 변수가 같은 메모리 주소와 연결되어 있으므로, 하나의 변수값만 바뀌더라도 둘 다 영향을 받는 것이다.
그리고 b에 새로운 값을 할당하게 되면 a와 b는 같은 메모리 주소와 연결되지 않게 된다.
따라서 a와 b를 출력하게 될 경우 b는 새로 할당된 값이 출력되지만 a는 아까 정렬된 값 그대로 출력된다.
여기서 =는 할당, 즉 메모리 주소를 연결해준다는 의미로 기억해두는 것이 더 편할 것이다.
'''